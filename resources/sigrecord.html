<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Signal recording simulator</title>
    <style>
        body { font-family: sans-serif; text-align: center; padding: 20px; background: #f4f4f4; }
        .controls { background: white; padding: 20px; border-radius: 8px; display: inline-block; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 20px;}
        input { padding: 8px; width: 120px; border: 1px solid #ccc; border-radius: 4px; font-size: 1rem; }
        
        canvas { background: #000; border: 2px solid #333; border-radius: 4px; margin-top: 20px; width: 100%; max-width: 800px; height: 250px; }
        
        .btn { display: inline-block; padding: 12px 24px; margin: 5px; font-weight: bold; color: white; background: #444; text-decoration: none; border-radius: 4px; border: none; cursor: pointer; }
        #start { background: #28a745; } #stop { background: #dc3545; } #save { background: #007bff; } #clear { background: #6c757d; }
        .btn.inactive { background: #ccc !important; color: #888; cursor: not-allowed; pointer-events: none; opacity: 0.6; }
        #status { font-family: monospace; margin-top: 15px; color: #333; line-height: 1.4; white-space: pre; }
        .legend { font-size: 0.9rem; margin-top: 5px; font-weight: bold; }
        .real { color: #00ff00; } .imag { color: #ff00ff; }
    </style>
</head>
<body>

    <h2>Complex IQ Signal Recorder</h2>
  <p>Learning how to record signals. Mostly generated by Google Gemini</p>

    <div class="controls">
        <label>Sample Rate: </label>
        <input type="number" id="spsInput" value="1000" step="10" min="10"> <strong>SPS</strong>
    </div>

    <br>
    <button id="start" class="btn">Start Recording</button>
    <button id="stop" class="btn">Stop Recording</button>
    <a id="save" class="btn inactive">Save</a>
    <button id="clear" class="btn">Clear</button>

    <div id="status">Status: Idle | Samples: 0 | Time: 0.00s</div>
    
    <canvas id="scope"></canvas>
    <div class="legend">
        <span class="real">━ Real (I) + Noise</span> &nbsp;&nbsp; 
        <span class="imag">━ Imaginary (Q) + Noise</span>
    </div>

    <script>
    let chunks = [];
    let interval = null;
    let totalSamples = 0;
    const freq = 20; 
    const noiseSigma = 0.05; // 5% of signal amplitude
    
    let scopeBuffer = []; 
    const SCOPE_HISTORY_LIMIT = 5; 

    const canvas = document.getElementById('scope');
    const ctx = canvas.getContext('2d');
    const spsInput = document.getElementById('spsInput');
    const status = document.getElementById('status');
    const saveBtn = document.getElementById('save');

    canvas.width = 800;
    canvas.height = 250;

    function updateUI(msg) {
        const duration = totalSamples / (parseFloat(spsInput.value) || 1);
        status.innerText = `Status: ${msg}\nSamples: ${totalSamples.toLocaleString()}\nDuration: ${duration.toFixed(2)}s\nNoise: 5% AWGN`;
    }

    function gaussianRandom(mean=0, stdev=1) {
        const u = 1 - Math.random(); 
        const v = Math.random();
        const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        return z * stdev + mean;
    }

    function drawScope() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "#333";
        ctx.beginPath(); ctx.moveTo(0, 125); ctx.lineTo(canvas.width, 125); ctx.stroke();

        const flatData = [];
        for (let chunk of scopeBuffer) {
            for (let val of chunk) flatData.push(val);
        }

        if (flatData.length === 0) return;
        const totalIQPairs = flatData.length / 2;
        const step = canvas.width / totalIQPairs;
        
        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for(let i=0; i < totalIQPairs; i++) {
            const x = i * step;
            const y = 125 - (flatData[i*2] * 100);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();

        ctx.strokeStyle = "#ff00ff";
        ctx.beginPath();
        for(let i=0; i < totalIQPairs; i++) {
            const x = i * step;
            const y = 125 - (flatData[i*2 + 1] * 100);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    document.getElementById('start').addEventListener('click', () => {
        if (interval) return;
        const sps = parseFloat(spsInput.value) || 1000;
        const samplesPerTick = sps / 10;

        saveBtn.classList.add('inactive');
        spsInput.disabled = true;
        updateUI("Recording...");

        // Random delay before signal starts
        const startDelay = (Math.random() * 1.7 + 0.3); // between 0.3 and 2s
        const startSample = startDelay * sps;

        let signalActive = false;
        let ticksSinceStart = 0;

        interval = setInterval(() => {
            const buffer = new Float32Array(samplesPerTick * 2);
            for (let i = 0; i < samplesPerTick; i++) {
                const currentSample = totalSamples + i;
                const t = currentSample / sps;
                let real = gaussianRandom(0, noiseSigma);
                let imag = gaussianRandom(0, noiseSigma);

                if (currentSample >= startSample && signalActive) {
                    const angle = 2 * Math.PI * freq * t;
                    real += 0.2 * Math.cos(angle);
                    imag += 0.2 * Math.sin(angle);
                }

                buffer[i * 2] = real;
                buffer[i * 2 + 1] = imag;
            }

            chunks.push(buffer.buffer);
            totalSamples += samplesPerTick;
            scopeBuffer.push(buffer);
            if (scopeBuffer.length > SCOPE_HISTORY_LIMIT) scopeBuffer.shift();

            drawScope();
            updateUI("Recording...");

            // Once signal has started, toggle on/off randomly every tick (0.1s)
            if (totalSamples >= startSample) {
                ticksSinceStart++;
                if (ticksSinceStart % 1 === 0) { // every tick ~0.1s
                    signalActive = Math.random() < 0.5; // 50% chance on/off
                }
            }
        }, 100);
    });

    document.getElementById('stop').addEventListener('click', () => {
        if (!interval) return;
        clearInterval(interval);
        interval = null;
        spsInput.disabled = false;
        updateUI("Stopped");
        
        const blob = new Blob(chunks, { type: 'application/octet-stream' });
        if (saveBtn.href) URL.revokeObjectURL(saveBtn.href);
        saveBtn.href = URL.createObjectURL(blob);
        saveBtn.download = `rec_${spsInput.value}SPS.complex`;
        saveBtn.classList.remove('inactive');
    });

    document.getElementById('clear').addEventListener('click', () => {
        if (interval) clearInterval(interval);
        interval = null;
        chunks = [];
        scopeBuffer = [];
        totalSamples = 0;
        spsInput.disabled = false;
        if (saveBtn.href) URL.revokeObjectURL(saveBtn.href);
        saveBtn.href = "#";
        saveBtn.classList.add('inactive');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        updateUI("Idle (Cleared)");
    });
</script>

</body>
</html>
